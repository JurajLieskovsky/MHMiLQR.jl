var documenterSearchIndex = {"docs":
[{"location":"guide/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"guide/#Installation","page":"Getting started","title":"Installation","text":"The package can be added to your project using the command\n\n] add https://github.com/JurajLieskovsky/MHMiLQR.jl.git\n\nin your REPL. For usage, we recommend taking a look at the examples.","category":"section"},{"location":"guide/#Running-Examples","page":"Getting started","title":"Running Examples","text":"To run the examples we recommend cloning main repository\n\ngit clone git@github.com:JurajLieskovsky/MHMiLQR.jl.git MHMiLQR\n\nNavigating to the MHMiLQR/examples folder and starting Julia\n\ncd MHMiLQR/examples\njulia\n\nIn the REPL, activating and instantiating the environment\n\nusing Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n\nRunning one of the examples\n\ninclude(\"cartpole/swing_up.jl\")","category":"section"},{"location":"generated/hover_to_hover/#Quadrotor-Recovery-Problem","page":"Quadrotor recovery","title":"Quadrotor Recovery Problem","text":"In this example we show how to optimize the recovery of a quadrotor in an MPC context. We use quaternions for the quadrotor's orientation which lie on a manifold in the state space. Therefore, in this example we show how to use the solver's capabilities to optimize directly on the manifold.","category":"section"},{"location":"generated/hover_to_hover/#Dependencies","page":"Quadrotor recovery","title":"Dependencies","text":"Two of the dependencies are not registered, namely QuadrotorODE.jl and MeshCatBenchmarkMechanisms.jl. However, if you if run the examples from a clone of the repository according to the [instructions] (@ref \"Running Examples\") in the docs, they load automatically.\n\nusing Revise\n\nusing MHMiLQR\nusing MHMiLQR: nominal_trajectory, active_trajectory\nusing QuadrotorODE\nusing MeshCatBenchmarkMechanisms\n\nusing LinearAlgebra\nusing ForwardDiff\nusing Plots\nusing DataFrames, CSV\nusing BenchmarkTools\nusing Infiltrator\nusing MatrixEquations","category":"section"},{"location":"generated/hover_to_hover/#Quadrotor-model","page":"Quadrotor recovery","title":"Quadrotor model","text":"We start by initializing a model of the quadrotor which stores its parameters. Although the code is unit-less, in practical terms we are using SI units throughout this example.\n\nquadrotor = QuadrotorODE.System(9.81, 0.5, diagm([0.0023, 0.0023, 0.004]), 0.1750, 1.0, 0.0245)","category":"section"},{"location":"generated/hover_to_hover/#Horizon-and-timestep","page":"Quadrotor recovery","title":"Horizon and timestep","text":"We will be optimizing the trajectory on a horizon of T=2s which we discretize into 200 steps.\n\nT = 2\nN = 200\nh = T / N","category":"section"},{"location":"generated/hover_to_hover/#Target","page":"Quadrotor recovery","title":"Target","text":"we set the target state and input as the equilibrium\n\nxₜ = vcat([0, 0, 1.0], [1, 0, 0, 0], zeros(3), zeros(3))\nuₜ = quadrotor.m * quadrotor.g / 4 * ones(4)","category":"section"},{"location":"generated/hover_to_hover/#Initial-state-and-inputs","page":"Quadrotor recovery","title":"Initial state and inputs","text":"As the initial state we will use a significant rotation around the x-axis\n\nθ₀ = 3 * pi / 4\nx₀ = vcat([0, 0, 1.0], [cos(θ₀ / 2), sin(θ₀ / 2), 0, 0], zeros(3), zeros(3))\n\nAnd for the inital input use a small utility function that calculates the dot product between the z-axes of a global and local frame of the quadrotor\n\nzRz(q⃗) = 1 - 2 * (q⃗[1]^2 + q⃗[2]^2)\n\nto produce an input that somewhat minimizes movement of the quadrotor in space\n\nu₀(_) = zRz(x₀[5:7]) * uₜ","category":"section"},{"location":"generated/hover_to_hover/#Dynamics","page":"Quadrotor recovery","title":"Dynamics","text":"To discretize the continuous-time dynamics of the system, we use a fourth order Runge-Kutta method\n\n\"\"\"RK4 integration with zero-order hold on u\"\"\"\nfunction dynamics!(xnew, x, u, _)\n    f1 = QuadrotorODE.dynamics(quadrotor, x, u)\n    f2 = QuadrotorODE.dynamics(quadrotor, x + 0.5 * h * f1, u)\n    f3 = QuadrotorODE.dynamics(quadrotor, x + 0.5 * h * f2, u)\n    f4 = QuadrotorODE.dynamics(quadrotor, x + h * f3, u)\n    xnew .= x + (h / 6.0) * (f1 + 2 * f2 + 2 * f3 + f4)\n    return nothing\nend\n\nand ForwardDiff.jl to obtain its Jacobians\n\nfunction dynamics_diff!(∇f, x, u, k)\n    nx = QuadrotorODE.nx\n    nu = QuadrotorODE.nu\n\n    @views ForwardDiff.jacobian!(\n        ∇f,\n        (xnew, arg) -> dynamics!(xnew, view(arg, 1:nx), view(arg, nx+1:nx+nu), k),\n        zeros(nx),\n        vcat(x, u)\n    )\n\n    return nothing\nend\n\nCost function As the running cost we can use a function that is quadratic in x and u\n\nfunction running_cost(x, u, _)\n    r, q, v, ω = x[1:3], x[4:7], x[8:10], x[11:13]\n    q⃗ = q[2:4]\n    dr = r - xₜ[1:3]\n    du = u - uₜ\n    return h * (dr'dr + q⃗'q⃗ / 4 + 1e-1 * v'v + 1e-1 * ω'ω + 1e-1 * du'du)\nend\n\nfunction running_cost_diff!(∇l, ∇2l, x, u, k)\n    nx = QuadrotorODE.nx\n    nu = QuadrotorODE.nu\n\n    result = DiffResults.DiffResult(0.0, (∇l, ∇2l))\n    @views ForwardDiff.hessian!(result, arg -> running_cost(view(arg, 1:nx), view(arg, nx+1:nx+nu), k), vcat(x, u))\n\n    return nothing\nend\n\nthis means that the final cost can be derived as the inifinite-horizon LQR value function. To calculate it, we use the the coordinate jacobian, which allows us to linearize the system's dynamics, as well as the running cost, on the state-space manifold\n\nS, _ = begin\n    nx = QuadrotorODE.nx\n    nu = QuadrotorODE.nu\n\n    ∇f, ∇l, ∇2l = zeros(nx, nx + nu), zeros(nx + nu), zeros(nx + nu, nx + nu)\n    dynamics_diff!(∇f, xₜ, uₜ, 0)\n    running_cost_diff!(∇l, ∇2l, xₜ, uₜ, 0)\n\n    E = QuadrotorODE.jacobian(xₜ)\n\n    A = E' * ∇f[:, 1:nx] * E\n    B = E' * ∇f[:, nx+1:nx+nu]\n    Q = 2 * E' * ∇2l[1:nx, 1:nx] * E\n    R = 2 * ∇2l[nx+1:nx+nu, nx+1:nx+nu]\n\n    MatrixEquations.ared(A, B, R, Q)\nend\n\nfunction final_cost(x, _)\n    dx = QuadrotorODE.state_difference(x, xₜ)\n    return dx' * S * dx\nend\n\nfunction final_cost_diff!(Φx, Φxx, x, k)\n    H = DiffResults.DiffResult(0.0, (Φx, Φxx))\n    ForwardDiff.hessian!(H, x_ -> final_cost(x_, k), x)\n\n    return nothing\nend","category":"section"},{"location":"generated/hover_to_hover/#Plotting-callback","page":"Quadrotor recovery","title":"Plotting callback","text":"During the optimization process we will plot the position and orientation of the quadrotor in space, as well as the inputs and cumulative cost.\n\nfunction plotting_callback(workset)\n    range = 0:workset.N\n\n    states = mapreduce(x -> x', vcat, nominal_trajectory(workset).x)\n    state_labels = [\"x\" \"y\" \"z\" \"q₀\" \"q₁\" \"q₂\" \"q₃\" \"vx\" \"vy\" \"vz\" \"ωx\" \"ωy\" \"ωz\"]\n    position_plot = plot(range, states[:, 1:7], label=state_labels[1:1, 1:7])\n\n    inputs = mapreduce(u -> u', vcat, nominal_trajectory(workset).u)\n    input_labels = [\"u₀\" \"u₁\" \"u₂\" \"u₃\"]\n    input_plot = plot(range, vcat(inputs, inputs[end, :]'), label=input_labels, seriestype=:steppost)\n\n    cost_plot = plot(range, cumsum(nominal_trajectory(workset).l), label=\"c\", seriestype=:steppost)\n\n    plt = plot(position_plot, input_plot, cost_plot, layout=(3, 1))\n    display(plt)\n\n    return plt\nend","category":"section"},{"location":"generated/hover_to_hover/#Optimization","page":"Quadrotor recovery","title":"Optimization","text":"First we initialize the workset based on the length of the horizon and dimensions of the systems state and input vector\n\nworkset = MHMiLQR.Workset{Float64}(QuadrotorODE.nx, QuadrotorODE.nu, N, QuadrotorODE.nz)","category":"section"},{"location":"generated/hover_to_hover/#Warmstart","page":"Quadrotor recovery","title":"Warmstart","text":"We first run and optimization that stabilizes the quadrotor at the target equilibrium. This will essentially computes the gains of an infinite-horizon LQR which will drastically improve the convergence rate of the second optimization from the perturbed state\n\nMHMiLQR.set_initial_state!(workset, xₜ)\nMHMiLQR.set_nominal_inputs!(workset, [uₜ for _ in 1:N])\n\nMHMiLQR.iLQR!(\n    workset, dynamics!, dynamics_diff!, running_cost, running_cost_diff!, final_cost, final_cost_diff!,\n    stacked_derivatives=true, regularization=:none,\n    state_difference=QuadrotorODE.state_difference, coordinate_jacobian=QuadrotorODE.jacobian,\n    verbose=true, plotting_callback=plotting_callback\n)\n\nNote that as the system's state lies on a manifold we supply state_difference and coordinate_jacobian to optimize directly on the manifold.","category":"section"},{"location":"generated/hover_to_hover/#Recovery","page":"Quadrotor recovery","title":"Recovery","text":"The second optimization is now run with rollout = :partial to re-use the gains from the previous optimization\n\nMHMiLQR.set_initial_state!(workset, x₀)\nwarmstart || MHMiLQR.set_initial_inputs!(workset, [u₀(k) for k in 1:N])\n\nMHMiLQR.iLQR!(\n    workset, dynamics!, dynamics_diff!, running_cost, running_cost_diff!, final_cost, final_cost_diff!,\n    stacked_derivatives=true, regularization=:none, rollout=:partial,\n    state_difference=QuadrotorODE.state_difference, coordinate_jacobian=QuadrotorODE.jacobian,\n    verbose=true, plotting_callback=plotting_callback,\n)","category":"section"},{"location":"generated/hover_to_hover/#Visualization","page":"Quadrotor recovery","title":"Visualization","text":"We can visualize the execution of the trajectory using MeshCat.jl for which we wrote a wrapper.\n\nvis = (@isdefined vis) ? vis : Visualizer()\nrender(vis)\n\nFirst we initialize the quadrotor and target\n\nMeshCatBenchmarkMechanisms.set_quadrotor!(vis, 2 * quadrotor.a, 0.07, 0.12)\nMeshCatBenchmarkMechanisms.set_target!(vis, 0.07)\n\nand their initial configurations\n\nMeshCatBenchmarkMechanisms.set_quadrotor_state!(vis, nominal_trajectory(workset).x[1])\nMeshCatBenchmarkMechanisms.set_target_position!(vis, xₜ[1:3])\n\nThen we animate the recovery\n\nanim = MeshCatBenchmarkMechanisms.Animation(vis, fps=1 / h)\nfor (i, x) in enumerate(nominal_trajectory(workset).x)\n    atframe(anim, i) do\n        MeshCatBenchmarkMechanisms.set_quadrotor_state!(vis, x)\n    end\nend\nsetanimation!(vis, anim, play=false);\nnothing #hide\n\nYou can view the animation in your browser at the address given by running > vis in your REPL.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/swing_up/#Cart-Pole-Swing-Up-Problem","page":"Cart-pole swing-up","title":"Cart-Pole Swing-Up Problem","text":"In this example we show how to optimize a cart-pole swing-up with an MPC-like cost function. The problem is highly non-convex, which means that it is a good showcase of the novel regularization approach.","category":"section"},{"location":"generated/swing_up/#Dependencies","page":"Cart-pole swing-up","title":"Dependencies","text":"Two of the dependencies are not registered, namely CartPoleODE.jl and MeshCatBenchmarkMechanisms.jl. However, if you if run the examples from a clone of the repository according to the [instructions] (@ref \"Running Examples\") in the docs, they load automatically.\n\nusing Revise\n\nusing CartPoleODE\nusing MeshCatBenchmarkMechanisms\n\nusing MHMiLQR\nusing MHMiLQR: nominal_trajectory\n\nusing ForwardDiff, DiffResults\nusing Plots\nusing DataFrames, CSV\nusing Infiltrator\nusing BenchmarkTools\nusing LinearAlgebra\nusing MatrixEquations","category":"section"},{"location":"generated/swing_up/#Cart-pole-model","page":"Cart-pole swing-up","title":"Cart-pole model","text":"We start by initializing a model of the cart-pole which stores its parameters. Although the code is unit-less, in practical terms we are using SI units throughout this example.\n\ncartpole = CartPoleODE.Model(9.81, 1, 0.1, 0.2)","category":"section"},{"location":"generated/swing_up/#Horizon-and-timestep","page":"Cart-pole swing-up","title":"Horizon and timestep","text":"We will be optimizing the trajectory on a horizon of T=2s which we discretize into 200 steps.\n\nT = 2\nN = 200\nh = T / N","category":"section"},{"location":"generated/swing_up/#Initial-state-and-inputs","page":"Cart-pole swing-up","title":"Initial state and inputs","text":"For the intial state and nominal control policy we use the stable equilibrium\n\nx₀ = [0.0, 0, 0, 0]\n\nand a simple harmonic input signal\n\nu₀(k) = cos(2 * pi * (k - 1) / N - 1) * ones(CartPoleODE.nu)\n\nwhich perturbs the initial trajectory from stable equilibrium, where the gradient is zero.","category":"section"},{"location":"generated/swing_up/#Regularization","page":"Cart-pole swing-up","title":"Regularization","text":"As the overall problem is highly non-convex, we use the eigen value regularization approach.\n\nregularization = :eig","category":"section"},{"location":"generated/swing_up/#Dynamics","page":"Cart-pole swing-up","title":"Dynamics","text":"To discretize the continuous-time dynamics of the system, we use a fourth order Runge-Kutta method\n\n\"\"\"RK4 integration with zero-order hold on u\"\"\"\nfunction dynamics!(xnew, x, u, _)\n    f1 = CartPoleODE.f(cartpole, x, u)\n    f2 = CartPoleODE.f(cartpole, x + 0.5 * h * f1, u)\n    f3 = CartPoleODE.f(cartpole, x + 0.5 * h * f2, u)\n    f4 = CartPoleODE.f(cartpole, x + h * f3, u)\n    xnew .= x + (h / 6.0) * (f1 + 2 * f2 + 2 * f3 + f4)\n    return nothing\nend\n\nand ForwardDiff.jl to obtain its Jacobians\n\nfunction dynamics_diff!(∇f, x, u, k)\n    nx = CartPoleODE.nx\n    nu = CartPoleODE.nu\n\n    @views ForwardDiff.jacobian!(\n        ∇f,\n        (xnew, arg) -> dynamics!(xnew, view(arg, 1:nx), view(arg, nx+1:nx+nu), k),\n        zeros(nx),\n        vcat(x, u)\n    )\n\n    return nothing\nend","category":"section"},{"location":"generated/swing_up/#Cost-functions","page":"Cart-pole swing-up","title":"Cost functions","text":"We base the running and final cost on a distance function from the equlibrium\n\nξ(x) = [x[1], cos(x[2] / 2), x[3], x[4]]\n\nAs ξ can also be regard as an alternative state (although the underlying representation has a singularity at the stable equilibrium) we may model the cost function after infinite-horizon LQR with weights\n\nQ = h * diagm([1e1, 1e2, 1, 1])\nR = h * Matrix{Float64}(I, 1, 1)\n\nThe final cost can be formed from the solution of the DARE for the alternative state-space representation\n\nS, _ = begin\n    x_eq = [0.0, pi, 0, 0]\n    u_eq = [0.0]\n\n    nx = CartPoleODE.nx\n    nu = CartPoleODE.nu\n\n    ∇f = zeros(nx, nx + nu)\n    dynamics_diff!(∇f, x_eq, u_eq, 0)\n\n    E = ForwardDiff.jacobian(ξ, x_eq)\n    A = E' * ∇f[:, 1:nx] * inv(E)\n    B = E' * ∇f[:, nx+1:nx+nu]\n\n    MatrixEquations.ared(A, B, R, Q)\nend\n\nThe running cost is then simply the quadratic form in ξ and u\n\nrunning_cost(x, u, _) = ξ(x)' * Q * ξ(x) + u' * R * u\n\nfunction running_cost_diff!(∇l, ∇2l, x, u, k)\n    nx = CartPoleODE.nx\n    nu = CartPoleODE.nu\n\n    H = DiffResults.DiffResult(0.0, (∇l, ∇2l))\n\n    @views ForwardDiff.hessian!(\n        H,\n        arg -> running_cost(view(arg, 1:nx), view(arg, nx+1:nx+nu), k),\n        vcat(x, u)\n    )\n\n    return nothing\nend\n\nAnd the final cost essentially a quadratic value function\n\nfinal_cost(x, _) = ξ(x)' * S * ξ(x)\n\nfunction final_cost_diff!(Φx, Φxx, x, k)\n    H = DiffResults.DiffResult(0.0, (Φx, Φxx))\n    ForwardDiff.hessian!(H, x -> final_cost(x, k), x)\n    return nothing\nend","category":"section"},{"location":"generated/swing_up/#Plotting-callback","page":"Cart-pole swing-up","title":"Plotting callback","text":"During the optimization process we will plot the position of the cart and angle of the pendulum as well as the input and cumulative cost.\n\nfunction plotting_callback(workset)\n    range = 0:workset.N\n\n    states = mapreduce(x -> x', vcat, nominal_trajectory(workset).x)\n    state_labels = [\"x₁\" \"x₂\" \"x₃\" \"x₄\"]\n    position_plot = plot(range, states[:, 1:2], label=state_labels[1:1, 1:2])\n\n    inputs = mapreduce(u -> u', vcat, nominal_trajectory(workset).u)\n    input_plot = plot(range, vcat(inputs, inputs[end, :]'), label=\"u\", seriestype=:steppost)\n\n    cost_plot = plot(range, cumsum(nominal_trajectory(workset).l), label=\"c\", seriestype=:steppost)\n\n    plt = plot(position_plot, input_plot, cost_plot, layout=(3, 1))\n    display(plt)\n\n    return plt\nend","category":"section"},{"location":"generated/swing_up/#Trajectory-optimization","page":"Cart-pole swing-up","title":"Trajectory optimization","text":"First we initialize the workset based on the length of the horizon and dimensions of the systems state and input vector\n\nworkset = MHMiLQR.Workset{Float64}(CartPoleODE.nx, CartPoleODE.nu, N)\n\nThen we set the initial state and nominal control policy\n\nMHMiLQR.set_initial_state!(workset, x₀)\nMHMiLQR.set_nominal_inputs!(workset, [u₀(k) for k in 1:N])\n\nHaving done so, we run the optimization\n\nMHMiLQR.iLQR!(\n    workset, dynamics!, dynamics_diff!, running_cost, running_cost_diff!, final_cost, final_cost_diff!,\n    stacked_derivatives=true, regularization=regularization,\n    verbose=true, plotting_callback=plotting_callback\n)","category":"section"},{"location":"generated/swing_up/#Visualization","page":"Cart-pole swing-up","title":"Visualization","text":"We can visualize the execution of the trajectory using MeshCat.jl for which we wrote a wrapper.\n\n(@isdefined vis) || (vis = Visualizer())\nrender(vis)\n\nFirst we initialize the cart-pole\n\nMeshCatBenchmarkMechanisms.set_cartpole!(vis, 0.1, 0.05, 0.05, cartpole.l, 0.02)\n\nthen set the initial configuration\n\nMeshCatBenchmarkMechanisms.set_cartpole_state!(vis, nominal_trajectory(workset).x[1])\n\nand finally animate the swing-up\n\nanim = MeshCatBenchmarkMechanisms.Animation(vis, fps=1 / h)\nfor (i, x) in enumerate(nominal_trajectory(workset).x)\n    atframe(anim, i) do\n        MeshCatBenchmarkMechanisms.set_cartpole_state!(vis, x)\n    end\nend\nsetanimation!(vis, anim, play=false)\n\nYou can view the animation in your browser at the address given by running > vis in your REPL.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Algorithm","page":"Reference","title":"Algorithm","text":"","category":"section"},{"location":"reference/#Workset","page":"Reference","title":"Workset","text":"","category":"section"},{"location":"reference/#Regularization","page":"Reference","title":"Regularization","text":"","category":"section"},{"location":"reference/#MHMiLQR.backward_pass!-Tuple{MHMiLQR.Workset}","page":"Reference","title":"MHMiLQR.backward_pass!","text":"Perform the backward pass of the algorithm. Mainly, produce the the terms d and K of the policy update as well as the expected improvement Δv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.cost_regularization!-Tuple{MHMiLQR.Workset, Real, Symbol}","page":"Reference","title":"MHMiLQR.cost_regularization!","text":"Regularize the hessians of the running cost l and final cost Φ. (multithreaded)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.differentiation!-Tuple{MHMiLQR.Workset, Function, Function, Function, Bool}","page":"Reference","title":"MHMiLQR.differentiation!","text":"Produce partial derivatives of the system's dynamics f and costs l and Φ that are required for the backward pass of the algorithm. (multithreaded)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.differentiation!-Tuple{MHMiLQR.Workset, Function, Function, Function, Function, Bool}","page":"Reference","title":"MHMiLQR.differentiation!","text":"Produce partial derivatives of the system's dynamics f and costs l and Φ   that are required for the backward pass of the algorithm. Also transform them   to the surface of the state manifold using coordinate jacobians. (multithreaded)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.forward_pass!-Tuple{MHMiLQR.Workset, Function, Function, Function, Function, Real}","page":"Reference","title":"MHMiLQR.forward_pass!","text":"Perform the forward pass of the algorithm, i.e. produce a candidate trajectory x, u.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.iLQR!-Tuple{MHMiLQR.Workset, Vararg{Function, 6}}","page":"Reference","title":"MHMiLQR.iLQR!","text":"Optimize the trajectory of a system with in-place dynamics! for the running_cost and final_cost on a horizon of length N. The number of the system's states nx and inputs nu as well as the horizon's length N must be compatible with the workset which is constructed using these quantities.\n\nFunctions dynamics_diff!, running_cost_diff!, and final_cost_diff! are used to calculate partial derivatives. They can either calculate each partial derivatives with respect to x and u separately:\n\ndynamics_diff!(fx, fu, x, u, k),\nrunning_cost_diff!(lx, lu, lxx, lxu, luu, x, u, k),\nfinal_cost_diff!(Φx, Φxx, x, k)\n\nor in a stacked form:\n\ndynamics_diff!(∇f, x, u, k),\nrunning_cost_diff!(∇l, ∇2l, x, u, k),\nfinal_cost_diff!(Φx, Φxx, x, k).\n\nIf the stacked form is used, set the keyword argument stacked_derivatives to True.\n\nIf the state of the system lies on a manifold, the keyword arguments state_difference and coordinate_jacobian must be supplied. Also ndx!=nx must have been used in the construction of workset.\n\nTo re-use the nominal control policy from a previous solve (for example in MPC applications) set rollout=:partial. The default rollout=:full uses the nominal inputs in feedforward manner to produce the states of the nominal trajectory.\n\nDuring the optimization, printout into the console can be switched of using by setting verbose=false. Instead of printing (or in addition to) information about each iteration can be stored in a dataframe::DataFrames.DataFrame by setting logging=true. If set true the dataframe is the only output of the function.\n\nQuantities in the workset can be plotted live using the plotting_callback keyword argument which expects a function with the signature plotting_callback(workset). It is called once after the intial rollout and then after every succesful iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.iteration_dataframe-Tuple{}","page":"Reference","title":"MHMiLQR.iteration_dataframe","text":"Create a data frame for logging information about the iterations of the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.log_iteration!-NTuple{13, Any}","page":"Reference","title":"MHMiLQR.log_iteration!","text":"Log information into the data frame about the iterations of the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.print_iteration!-NTuple{13, Any}","page":"Reference","title":"MHMiLQR.print_iteration!","text":"Print information about the current iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.trajectory_rollout!-Tuple{MHMiLQR.Workset, Function, Function, Function}","page":"Reference","title":"MHMiLQR.trajectory_rollout!","text":"Roll-out the states x̄ₖ of the nominal trajectory from the initial state x̃₁ and nominal inputs ūₖ. Also evaluate the running costs lₖ in multiple threads and the final cost Φ. \n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.BackwardPassWorkset","page":"Reference","title":"MHMiLQR.BackwardPassWorkset","text":"Struct containing quantities used exclusively in the backward pass of the algorithm.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MHMiLQR.CoordinateJacobians","page":"Reference","title":"MHMiLQR.CoordinateJacobians","text":"Struct containing coordinate jacobians Eₖ.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MHMiLQR.CostDerivatives","page":"Reference","title":"MHMiLQR.CostDerivatives","text":"Struct containing partial derivatives of the running cost l and the final cost Φ.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MHMiLQR.DynamicsDerivatives","page":"Reference","title":"MHMiLQR.DynamicsDerivatives","text":"Struct containing partial derivatives of the system's dyanamics f.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MHMiLQR.PolicyUpdate","page":"Reference","title":"MHMiLQR.PolicyUpdate","text":"Struct containing terms dₖ and Kₖ of the policy update δuₖ(δxₖ) = dₖ + Kₖδxₖ.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MHMiLQR.Trajectory","page":"Reference","title":"MHMiLQR.Trajectory","text":"Struct containing a trajectory xₖ, uₖ of the controlled system (including costs).\n\n\n\n\n\n","category":"type"},{"location":"reference/#MHMiLQR.Workset","page":"Reference","title":"MHMiLQR.Workset","text":"Struct containing the nominal trajectory (current the most optimal) as well as all internal quantities of the algorithm.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MHMiLQR.Workset-Union{Tuple{Int64, Int64, Int64}, NTuple{4, Int64}, Tuple{T}} where T","page":"Reference","title":"MHMiLQR.Workset","text":"Create a Workset for the trajectory optimization problem.\n\nArguments\n\nnx: number of states\nnu: number of inputs\nN: length of the optimizations horizon \nndx: number of independent states (defaults to nx)\n\nReturns\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.active_trajectory-Tuple{MHMiLQR.Workset}","page":"Reference","title":"MHMiLQR.active_trajectory","text":"Access the active trajectory\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.nominal_trajectory-Tuple{MHMiLQR.Workset}","page":"Reference","title":"MHMiLQR.nominal_trajectory","text":"Access the nominal trajectory\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.set_initial_state!-Tuple{MHMiLQR.Workset, Vector}","page":"Reference","title":"MHMiLQR.set_initial_state!","text":"Set the initial state x̃₁.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.set_nominal_inputs!","page":"Reference","title":"MHMiLQR.set_nominal_inputs!","text":"Set the nominal inputs ūₖ.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MHMiLQR.swap_trajectories!-Tuple{MHMiLQR.Workset}","page":"Reference","title":"MHMiLQR.swap_trajectories!","text":"Swap the nominal and active trajectory (without copying any data).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.eigenvalue_regularization!-Tuple{Any, Real}","page":"Reference","title":"MHMiLQR.eigenvalue_regularization!","text":"Regularizes H using the eigenvalue approach, so that all of its eigen values are >=δ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.gmw_regularization!-Tuple{Any, Any}","page":"Reference","title":"MHMiLQR.gmw_regularization!","text":"Regularized H using the Gill-Murray-Wright modified Cholesky factorization.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MHMiLQR.regularize!-Tuple{AbstractMatrix, Real, Symbol}","page":"Reference","title":"MHMiLQR.regularize!","text":"Regularizes the symmetric matrix H so that it is positive definite. The argument approach determines if an eigenvalue approach is taken eigenvalue_regularization! or the GMW modified Cholesky decomposition algorithm is used gmw_regularization!.\n\n\n\n\n\n","category":"method"},{"location":"#MHMiLQR.jl","page":"Home","title":"MHMiLQR.jl","text":"MHMiLQR.jl is a Julia package for unconstrained trajectory optimization. It implements regularization using minimal Hessian modification (MHM) on top of the iterative linear-quadratic regulator (iLQR). This form of regularization makes the algorithm particularly adept at solving highly non-convex problems.\n\nThe implementation also efficiently handles states that lie on a manifold, such as the SO(3) group in the case of quaternions, by projecting partial derivatives onto the manifold.","category":"section"},{"location":"#Solved-problem","page":"Home","title":"Solved problem","text":"In particular, the algorithm solves the unconstrained trajectory optimization problem\n\nbeginaligned\nmin_x_0N u_0N-1 enspace Phi(x_N N) + sum_k=0^N-1 l(x_ku_kk) \ntextst enspace x_k+1 = f(x_ku_kk) quad forall k in 0 dots N-1 \n\t\t\tenspace x_0 = tildex_0\nendaligned\n\nwhere x_k and u_k are the state and input of the system, Phi is the final cost; l is the running cost; f are the discrete-time dynamics of the system; tildex_0 is the initial state; and N in mathbbN is the length of the horizon.","category":"section"}]
}
